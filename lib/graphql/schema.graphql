enum condition {
  equals
  notEqual
  contains
  notContains
  startsWith
  endsWith
  greaterThan
  greaterThanOrEqual
  lessThan
  lessThanOrEqual
  isNull
  notNull
  whereIn
}

type deleted {
  id: String!
}

type Districts {
  created_at: Time
  fax: String
  governor: String
  id: Int!
  name_en: String
  name_mn: String
  object_id: Int
  phone: String
  tailbar: String
  update_at: Time
  website: String
  regions: [Regions!]
}

type DsNotifcation {
  body: String
  created_at: Time
  link: String
  not_status_id: Int
  notif_id: Int
  receiver_id: Int
  seen: Int
  seen_time: Time
  sender: Int
  title: String
}

type DsRequestConflicts {
  created_at: Time
  description: String
  ended_at: Time
  first_name: String
  fixer_description: String
  fixer_first_name: String
  fixer_id: Int
  fixer_image: String
  fixer_last_name: String
  id: Int
  last_name: String
  location: String
  name: String
  name_conflict: String
  name_conflict_group: String
  name_district: String
  name_org: String
  name_region: Int
  req_image: String
  requested_item_id: String
  requested_org_id: Int
  requested_user_id: Int
  status_id: Int
  status_name: String
  type_id: Int
  type_name: String
  updated_by_at: Time
  user_permission_id: Int
}

input filter {
  column: String!
  condition: condition!
  value: String!
}

enum order {
  asc
  desc
}

type paginate {
  page: Int!
  total: Int!
  last_page: Int!
  regions: [Regions!]
  districts: [Districts!]
  ds_notifcation: [DsNotifcation!]
  ds_request_conflicts: [DsRequestConflicts!]
}

type Query {
  regions(sorts: [sort], filters: [filter], limit: Int, offset: Int): [Regions!]
  districts(
    sorts: [sort]
    filters: [filter]
    subSorts: [subSort]
    subFilters: [subFilter]
    limit: Int
    offset: Int
  ): [Districts!]
  ds_notifcation(
    sorts: [sort]
    filters: [filter]
    limit: Int
    offset: Int
  ): [DsNotifcation!]
  ds_request_conflicts(
    sorts: [sort]
    filters: [filter]
    limit: Int
    offset: Int
  ): [DsRequestConflicts!]
  paginate(
    sorts: [sort]
    filters: [filter]
    subSorts: [subSort]
    subFilters: [subFilter]
    page: Int!
    size: Int!
  ): paginate!
}

type Regions {
  created_at: Time
  district_id: Int
  governor: String
  id: Int!
  name: Int
  object_id: Int
  phone: String
  updated_at: Time
}

input sort {
  column: String!
  order: order!
}

input subFilter {
  column: String!
  table: String!
  condition: condition!
  value: String!
}

input subSort {
  column: String!
  table: String!
  order: order!
}

type subTable {
  table: String!
  parentIdentity: String!
  ConnectionField: String!
}

scalar Time

